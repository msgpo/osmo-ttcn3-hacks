module GTP_Templates {

	import from General_Types all;
	import from Osmocom_Types all;
	import from GTPC_Types all;
	import from GTPU_Types all;
	import from GTP_CodecPort all;
	import from IPCP_Types all;

	/* generalized GTP-C receive template */
	template PDU_GTPC tr_GTP1C_PDU(template OCT1 msg_type, template OCT4 teid, template GTPC_PDUs pdu := ?) := {
		/* N-PDU Number flag (PN) shall be set to '0'. A GTP-C receiver shall not return an
		 * error if this flag is set to '1'. */
		pn_bit := '0'B,
		/* Sequence number flag (S) shall be set to '1'. */
		s_bit := '1'B,
		e_bit := ?,
		spare := ?,
		/* Protocol Type flag (PT) shall be set to '1'.*/
		pt := '1'B,
		/* Version shall be set to decimal 1 ('001'). */
		version := '001'B,
		messageType := msg_type,
		lengthf := ?,
		teid := teid,
		opt_part := *,
		gtpc_pdu := pdu
	}

	/* generalized GTP-C send template */
	template PDU_GTPC ts_GTP1C_PDU(OCT1 msg_type, OCT4 teid, GTPC_PDUs pdu, uint16_t seq_nr) := {
		/* N-PDU Number flag (PN) shall be set to '0'. A GTP-C receiver shall not return an
		 * error if this flag is set to '1'. */
		pn_bit := '0'B,
		/* Sequence number flag (S) shall be set to '1'. */
		s_bit := '1'B,
		e_bit := '0'B,
		spare := '0'B,
		/* Protocol Type flag (PT) shall be set to '1'.*/
		pt := '1'B,
		/* Version shall be set to decimal 1 ('001'). */
		version := '001'B,
		messageType := msg_type,
		lengthf := 0,	/* we assume encoder overwrites this */
		teid := teid,
		opt_part := {
			sequenceNumber := int2oct(seq_nr, 2),
			npduNumber := '00'O,
			nextExtHeader := '00'O,
			gTPC_extensionHeader_List := omit
		},
		gtpc_pdu := pdu
	}

	/* recovery IE */
	template Recovery_gtpc ts_Recovery(OCT1 restart_counter) := {
		type_gtpc := '0E'O,
		restartCounter := restart_counter
	}

	template Recovery_gtpc tr_Recovery(template OCT1 restart_counter) := {
		type_gtpc := '0E'O,
		restartCounter := restart_counter
	}

	/* template matching reception of GTP-C echo-request */
	template Gtp1cUnitdata tr_GTPC_MsgType(template GtpPeer peer, template OCT1 msg_type, template OCT4 teid, template GTPC_PDUs pdus := ?) := {
		peer := peer,
		gtpc := tr_GTP1C_PDU(msg_type, teid, pdus)
	}

	/* template matching reception of GTP-C echo-request */
	template Gtp1cUnitdata tr_GTPC_PING(template GtpPeer peer) := tr_GTPC_MsgType(peer, echoRequest, '00000000'O);

	template GTPC_PDUs tr_EchoRespPDU(template OCT1 restart_counter) := {
		echoResponse := {
			recovery := tr_Recovery(restart_counter),
			private_extension_gtpc := *
		}
	}

	/* template matching reception of GTP-C echo-response */
	template Gtp1cUnitdata tr_GTPC_PONG(template GtpPeer peer) := tr_GTPC_MsgType(peer, echoResponse, '00000000'O, tr_EchoRespPDU(?));

	template GTPC_PDUs ts_EchoRespPDU(OCT1 restart_counter) := {
		echoResponse := {
			recovery := ts_Recovery(restart_counter),
			private_extension_gtpc := omit
		}
	}

	/* master template for senidng a GTP-C echo response */
	template Gtp1cUnitdata ts_GTPC_PONG(GtpPeer peer, uint16_t seq, OCT1 rest_ctr) := {
		peer := peer,
		gtpc := ts_GTP1C_PDU(echoResponse, '00000000'O, valueof(ts_EchoRespPDU(rest_ctr)), seq)
	}

	template GTPC_PDUs ts_EchoReqPDU := {
		echoRequest := {
			private_extension_gtpc := omit
		}
	}

	/* master template for sending a GTP-C echo request */
	template Gtp1cUnitdata ts_GTPC_PING(GtpPeer peer, uint16_t seq) := {
		peer := peer,
		gtpc := ts_GTP1C_PDU(echoRequest, '00000000'O, valueof(ts_EchoReqPDU), seq)
	}

	template EndUserAddress t_EuaIPv4(template OCT4 ip_addr) := {
		type_gtpc := '80'O,
		endUserAddress := {
			endUserAddressIPv4 := {
				lengthf := 2,
				pdp_typeorg := '0001'B,
				spare := '1111'B,
				pdp_typenum := '21'O,
				ipv4_address := ip_addr
			}
		}
	}
	template EndUserAddress t_EuaIPv4Dyn := t_EuaIPv4(omit);
	template EndUserAddress tr_EuaIPv4(template OCT4 ip_addr) modifies t_EuaIPv4 := {
		endUserAddress := {
			endUserAddressIPv4 := {
				lengthf := 2+lengthof(ip_addr)
			}
		}
	}

	template EndUserAddress t_EuaIPv6(template OCT16 ip_addr) := {
		type_gtpc := '80'O,
		endUserAddress := {
			endUserAddressIPv6 := {
				lengthf := 2,
				pdp_typeorg := '0001'B,
				spare := '1111'B,
				pdp_typenum := '57'O,
				ipv6_address := ip_addr
			}
		}
	}
	template EndUserAddress t_EuaIPv6Dyn := t_EuaIPv6(omit);
	template EndUserAddress tr_EuaIPv6(template OCT16 ip_addr) modifies t_EuaIPv6 := {
		endUserAddress := {
			endUserAddressIPv6 := {
				lengthf := 2+lengthof(ip_addr)
			}
		}
	}

	template AccessPointName ts_APN(octetstring apn) := {
		type_gtpc := '83'O,
		lengthf := lengthof(apn),
		apn_value := apn
	}

	template GSN_Address_GTPC ts_GsnAddr(octetstring ip_addr) := {
		type_gtpc := '85'O,
		lengthf := lengthof(ip_addr),
		addressf := ip_addr
	}

	template MSISDN ts_Msisdn(octetstring msisdn) := {
		type_gtpc := '86'O,
		lengthf := lengthof(msisdn),
		msisdn := msisdn
	}

	template QualityOfServiceProfile ts_QosDefault := {
		type_gtpc := '87'O,
		lengthf := 4,
		allocRetensionPrio := '00'O,
		qos_ProfileValue := {
			reliabilityClass := '011'B,
			delayClass := '001'B,
			spare1 := '00'B,
			precedenceClass := '010'B,
			spare2 := '0'B,
			peakThroughput := '1001'B,
			meanThroughput := '11111'B,
			spare3 := '000'B,
			deliverErroneusSDU := omit,
			deliveryOrder := omit,
			trafficClass := omit,
			maxSDUSize := omit,
			maxBitrateUplink := omit,
			maxBitrateDownlink := omit,
			sduErrorRatio := omit,
			residualBER := omit,
			trafficHandlingPriority := omit,
			transferDelay := omit,
			guaranteedBitRateUplink := omit,
			guaranteedBitRateDownlink := omit,
			sourceStatisticsDescriptor := omit,
			signallingIndication := omit,
			spare4 := omit,
			maxBitrateDownlinkExt := omit,
			guaranteedBitRateDownlinkExt := omit,
			maxBitrateUplinkExt := omit,
			guaranteedBitRateUplinkExt := omit
		}
	}

	template IMSI_gtpc ts_Imsi(hexstring digits) := {
		type_gtpc := '02'O,
		digits := digits,
		padding := 'F'H
	}

	template GTPC_PDUs ts_CreatePdpPDU(hexstring imsi, OCT1 restart_ctr, OCT4 teid_data, OCT4 teid_ctrl,
					   BIT4 nsapi, EndUserAddress eua, octetstring apn,
					   octetstring sgsn_ip_sign, octetstring sgsn_ip_data,
					   octetstring msisdn, template ProtConfigOptions pco := omit) := {
		createPDPContextRequest := {
			imsi := ts_Imsi(imsi),
			rai := omit,
			recovery := ts_Recovery(restart_ctr),
			selectionMode := {
				type_gtpc := '0F'O,
				selectModeValue := '00'B,
				spare := '111111'B
			},
			teidDataI := {
				type_gtpc := '00'O,
				teidDataI := teid_data
			},
			teidControlPlane := {
				type_gtpc := '00'O,
				teidControlPlane := teid_ctrl
			},
			nsapi := {
				type_gtpc := '00'O,
				nsapi := nsapi,
				unused := '0000'B
			},
			linked_nsapi := omit,
			charging_char := omit,
			trace_ref := omit,
			trace_type := omit,
			endUserAddress := eua,
			accessPointName := ts_APN(apn),
			protConfigOptions := pco,
			sgsn_addr_signalling := ts_GsnAddr(sgsn_ip_sign),
			sgsn_addr_traffic := ts_GsnAddr(sgsn_ip_data),
			msisdn := ts_Msisdn(msisdn),
			qualityOfServiceProfile := ts_QosDefault,
			tft := omit,
			triggerId := omit,
			omcId := omit,
			commonFlags := omit,
			aPN_Restriction := omit,
			ratType := omit,
			userLocationInformation := omit,
			mS_TimeZone := omit,
			imeisv := omit,
			camelChargingInformationContainer := omit,
			additionalTraceInfo := omit,
			correlationID := omit,
			evolvedAllocationRetentionPriorityI := omit,
			extendedCommonFlags := omit,
			userCSGInformation := omit,
			aPN_AMBR := omit,
			signallingPriorityIndication := omit,
			cN_OperatorSelectionEntity := omit,
			private_extension_gtpc := omit
		}
	}

	template Gtp1cUnitdata ts_GTPC_CreatePDP(GtpPeer peer, uint16_t seq, hexstring imsi,
						 OCT1 restart_ctr, OCT4 teid_data,
						 OCT4 teid_ctrl, BIT4 nsapi, EndUserAddress eua,
						 octetstring apn, octetstring sgsn_ip_sign,
						 octetstring sgsn_ip_data, octetstring msisdn,
						 template ProtConfigOptions pco := omit) := {
		peer := peer,
		gtpc := ts_GTP1C_PDU(createPDPContextRequest, '00000000'O,
					valueof(ts_CreatePdpPDU(imsi, restart_ctr, teid_data, teid_ctrl,
								nsapi, eua, apn, sgsn_ip_sign,
								sgsn_ip_data, msisdn, pco)), seq)
	}

	/* PCO send base template */
	template ProtConfigOptions ts_PCO := {
		type_gtpc := '84'O,
		lengthf := 0,
		configProtocol := '000'B,
		spare := '0000'B,
		extension0 := '1'B,
		protocols := {}
	}
	/* PCO receive base template */
	template ProtConfigOptions tr_PCO := {
		type_gtpc := '84'O,
		lengthf := ?,
		configProtocol := '000'B,
		spare := ?,
		extension0 := '1'B,
		protocols := {}
	}

	template ProtConfigOptions ts_PCO_IPv6_DNS modifies ts_PCO := {
		protocols := {
			{ protocolID := '0003'O, lengthProtoID := 0, protoIDContents := ''O }
		}
	}
	template ProtConfigOptions tr_PCO_IPv6_DNS_resp(template OCT16 contents) modifies tr_PCO := {
		protocols := {
			*, { protocolID := '0003'O, lengthProtoID := 16, protoIDContents := contents }, *
		}
	}

	template ProtConfigOptions ts_PCO_IPv4_DNS_IPCP modifies ts_PCO := {
		protocols := {
			/* dummy PAP entry to check if our parser in the GGSN can properly iterate over
			 * the list of protocols, see Change-Id Icc2e6716c33d78d3c3e000f529806228d8aa155e */
			{ protocolID := 'C023'O, lengthProtoID := 0, protoIDContents := ''O },
			{ protocolID := '8021'O, lengthProtoID := 16, protoIDContents :=
								enc_IpcpPacket(valueof(ts_IPCP_ReqDNS)) }
		}
	}

	template ProtocolElement tr_PCO_Proto(OCT2 prot_id) := {
		protocolID := prot_id,
		lengthProtoID := ?,
		protoIDContents := ?
	}
	template ProtConfigOptions tr_PCO_Contains(OCT2 prot_id) modifies tr_PCO := {
		protocols := { *, tr_PCO_Proto(prot_id), * }
	}

	template ProtConfigOptions ts_PCO_IPv4_DNS_CONT modifies ts_PCO := {
		protocols := {
			{ protocolID := '000d'O, lengthProtoID := 0, protoIDContents := ''O }
		}
	}
	template ProtConfigOptions tr_PCO_IPv4_DNS_CONT_resp(template OCT4 contents) modifies tr_PCO := {
		protocols := {
			*, { protocolID := '000d'O, lengthProtoID := 4, protoIDContents := contents }, *
		}
	}

	/* extract a given protocol payload from PCO */
	function f_PCO_extract_proto(ProtConfigOptions pco, OCT2 protocol, integer nth_match := 1) return octetstring {
		var integer i;
		var integer num_matches := 0;
		for (i := 0; i < lengthof(pco.protocols); i := i + 1) {
			if (pco.protocols[i].protocolID == protocol) {
				num_matches := num_matches + 1;
				if (num_matches == nth_match) {
					return pco.protocols[i].protoIDContents;
				}
			}
		}
		setverdict(fail);
		return ''O;
	}

	template IpcpPacket tr_IPCP(template LcpCode code, template uint8_t identifier,
				    template IpcpOptionList opts) := {
		code := code,
		identifier := identifier,
		len := ?,
		options := opts
	}
	template IpcpOption tr_IPCP_PrimaryDns(template OCT4 addr) := {
		code := IPCP_OPT_PrimaryDNS,
		len := 6,
		data := addr
	}
	template IpcpOption tr_IPCP_SecondaryDns(template OCT4 addr) := {
		code := IPCP_OPT_SecondaryDNS,
		len := 6,
		data := addr
	}
	template IpcpPacket tr_IPCP_Ack_DNS(template uint8_t identifier := ?, template OCT4 dns1 := ?,
					    template OCT4 dns2 := ?) :=
		tr_IPCP(LCP_Configure_Ack, identifier,
				{ *, tr_IPCP_PrimaryDns(dns1), *, tr_IPCP_SecondaryDns(dns2), * });

	template IpcpPacket ts_IPCP(LcpCode code, uint8_t identifier, template IpcpOptionList opts) := {
		code := code,
		identifier := identifier,
		len := 0,	/* overwritten */
		options := opts
	}
	template IpcpPacket ts_IPCP_ReqDNS(uint8_t identifier := 0) :=
		ts_IPCP(LCP_Configure_Request, identifier,
			{ tr_IPCP_PrimaryDns('00000000'O), tr_IPCP_SecondaryDns('00000000'O) });

	function f_teardown_ind_IE(in template BIT1 ind) return template TearDownInd {
/*
		if (not isvalue(ind)) {
			return omit;
		}
*/
		var TearDownInd ret := {
			type_gtpc := '13'O,
			tdInd := valueof(ind),
			spare:= '0000000'B
		}
		return ret;
	}

	template GTPC_PDUs ts_DeletePdpPDU(BIT4 nsapi, template BIT1 teardown_ind) := {
		deletePDPContextRequest := {
			cause := omit,
			tearDownIndicator := f_teardown_ind_IE(teardown_ind),
			nsapi := {
				type_gtpc := '14'O,
				nsapi := nsapi,
				unused := '0000'B
			},
			protConfigOptions := omit,
			userLocationInformation := omit,
			mS_TimeZone := omit,
			extendedCommonFlags := omit,
			uLI_Timestamp := omit,
			private_extension_gtpc := omit
		}
	}

	template Gtp1cUnitdata ts_GTPC_DeletePDP(GtpPeer peer, uint16_t seq, OCT4 teid,
						 BIT4 nsapi, template BIT1 teardown_ind) := {
		peer := peer,
		gtpc := ts_GTP1C_PDU(deletePDPContextRequest, teid,
					valueof(ts_DeletePdpPDU(nsapi, teardown_ind)), seq)
	}


	/* GTP-U */

	template PDU_GTPU tr_GTP1U_PDU(template OCT1 msg_type, template OCT4 teid, template GTPU_IEs ies := ?) := {
		pn_bit := ?,
		s_bit := ?,
		e_bit := ?,
		spare := ?,
		/* Protocol Type flag (PT) shall be set to '1' in GTP */
		pt := '1'B,
		/* Version shall be set to decimal 1 ('001'). */
		version := '001'B,
		messageType := msg_type,
		lengthf := ?,
		teid := teid,
		opt_part := *,
		gtpu_IEs := ies
	}

	/* generalized GTP-U send template */
	template PDU_GTPU ts_GTP1U_PDU(OCT1 msg_type, uint16_t seq, OCT4 teid, GTPU_IEs ies) := {
		/* N-PDU Number flag (PN): the GTP-U header contains a meaningful N-PDU Number field if the PN
		 * flag is set to 1. */
		pn_bit := '0'B,	/* we assume the encoder overwrites this if an optional part is given */
		/* If the Sequence Number flag (S) is set to '1' the sequence number field is present and
		 * meaningful otherwise it is set to '0'. For GTP-U messages Echo Request, Echo Response,
		 * Error Indication and Supported Extension Headers Notification, the S flag shall be set to '1'. */
		s_bit := '1'B, 	/* we assume the encoder overwrites this if an optional part is given */
		/* Extension header presence */
		e_bit := '0'B,
		spare := '0'B,
		/* Protocol Type flag (PT) shall be set to '1' in GTP */
		pt := '1'B,
		/* Version shall be set to decimal 1 ('001'). */
		version := '001'B,
		messageType := msg_type,
		lengthf := 0,	/* we assume encoder overwrites this */
		teid := teid,
		opt_part :=  {
			sequenceNumber := int2oct(seq, 2),
			npduNumber := '00'O,
			nextExtHeader := '00'O,
			gTPU_extensionHeader_List := omit
		},
		gtpu_IEs := ies
	}

	template Gtp1uUnitdata tr_GTPU_MsgType(template GtpPeer peer, template OCT1 msg_type, template OCT4 teid) := {
		peer := peer,
		gtpu := tr_GTP1U_PDU(msg_type, teid)
	}


	/* template matching reception of GTP-U echo-request */
	template Gtp1uUnitdata tr_GTPU_PING(template GtpPeer peer) := tr_GTPU_MsgType(peer, echoRequest, '00000000'O);

	/* template matching reception of GTP-U GPDU */
	template GTPU_IEs t_GPDU(template octetstring data) := {
		g_PDU_IEs := {
			data := data
		}
	}
	template Gtp1uUnitdata tr_GTPU_GPDU(template GtpPeer peer, template OCT4 teid, template octetstring data := ?) := {
		peer := peer,
		gtpu := tr_GTP1U_PDU('FF'O, teid, t_GPDU(data))
	}

	template GTPU_IEs ts_UEchoRespPDU(OCT1 restart_counter) := {
		echoResponse_IEs := {
			recovery_gtpu := {
				type_gtpu := '00'O, /* we assume encoder fixes? */
				restartCounter := restart_counter
			},
			private_extension_gtpu := omit
		}
	}

	/* master template for sending a GTP-U echo response */
	template Gtp1uUnitdata ts_GTPU_PONG(GtpPeer peer, uint16_t seq, OCT1 rest_ctr) := {
		peer := peer,
		gtpu := ts_GTP1U_PDU(echoResponse, seq, '00000000'O, valueof(ts_UEchoRespPDU(rest_ctr)))
	}

	/* master template for sending a GTP-U user plane data */
	template Gtp1uUnitdata ts_GTP1U_GPDU(GtpPeer peer, uint16_t seq, OCT4 teid, octetstring data) := {
		peer := peer,
		gtpu := ts_GTP1U_PDU('FF'O, seq, teid, { g_PDU_IEs := { data := data }})
	}
}
